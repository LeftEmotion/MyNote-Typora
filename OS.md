位（bit）表示二进制位

字节（byte/B）一字节等于八位

字（word) 一般来说一字等于两字节 而且计算机的字长决定了CPU一次操作实际处理的位数的多少

1K = 2^10 B

1M = 2 ^ 20 B

进程的本质是操作系统执行的一个程序，与每个进程相关的就是地址空间

地址空间是从某个最小值的存储位置到某个最大值的存储位置的列表

在这个空间中，进程可以进行读写操作，而且还存放了可执行程序，程序所需要的数据和它的栈

资源集通常包括寄存器（PC 程序计数器，SP 堆栈指针）

创建文件、删除文件、读文件和写文件都需要系统调用

进程三部分 文本区（程序代码） 数据区（变量） 栈区域

数据向上增长而堆栈向下增长

一个进程就是一个运行程序的实例

几个创建进程的举例：

1.正在运行的程序执行了fork

2.用户创建了一个新进程

3.系统需要初始化

4.批处理初始化



CPU的工作原理：自动的取指，执行

IO指令的执行时间比计算指令花费更多很多

一个CPU上交替的执行多个程序：并发

每个程序有一个存放信息的结构——PCB

```c++
int main(int argc, char* argv[]){
	while(1){
		scanf("%s",cmd);
		if(!fork()){
			exec(cmd);
			wait();
		}
	}
}
```

```c++
//启动磁盘读写;
p.cur.state = 'W';//转成堵塞态
//将pCur放到DiskWaitQueue;//放到等待队列上
schedule();//切换

schedule(){
    pNew = getNext(RedayQueue);//在就绪队列中找到下一个进程（调度）
    switch_to(pCur,pNew);//恢复现场
}
```

多进程的组织：PCB+状态+队列

1.运行态 指的是进程实际占用CPU时间片运行时

2.就绪态 指的是可运行，但因为其他进程正在运行而处于就绪状态

3.阻塞态 除非某种外部事件发生，否则进程不能运行



交替的三个部分：队列操作+调度+切换

程序调度指的是，决定哪个进程优先被运行和运行多久

操作系统最底层的就是调度程序



如何形成多进程图像

1. 读写PCB，OS中最重要的结构，贯穿始终
2. 要操作寄存器完成切换
3. 要写调度程序
4. 要有进程同步与合作
5. 要有地址映射



进程 = 资源 + 指令执行序列

- 将资源和指令执行分开
- 一个资源 + 多个指令执行序列





操作系统为了执行进程间的转换，会维护一张表格，就是进程表。

三列分别是：进程管理、存储管理、文件管理



多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程不具备的

线程比进程更加轻量级，由于线程更轻，所以它更容易创建与撤销。

如果存在大量计算和IO处理，拥有多个线程能在这些活动中重叠进行，以此加快程序执行速度



线程可以分别在用户空间、内核空间、以及用户和内核空间中混合使用



两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这个情况就是竞态条件



互斥：禁止一个或多个进程在同一时刻对共享资源进行读写



我们把共享内存进行访问的程序片段称作临界区域



考虑有单个共享的锁变量，初始值为零。如果为1则意味着有进程在关键区域内。



连续检查一个变量直到某个值出现为止，这种方式称为忙等待。

用于忙等待的锁，称为自旋锁。



信号量表示需要的唤醒次数



down操作会检查sign值，如果该值为0，则进程将睡眠

```c++
if(sign > 0)
	sign--;
else
	process.sleep();
```

up操作会使信号值+1

对一个进程在其上睡眠的信号量执行一次up操作之后，该信号量为0，但在其上睡眠的进程却少了一个。



检查数值，修改变量值以及可能发生的睡眠操作均为单一、不可分割的原子操作完成。这会保证一旦操作量操作开始，没有其他的进程能够访问信号量，直至操作完成或者阻塞。

原子操作指的是一组相关操作全部执行而没有中断或不执行

中断的顺序保证

1. 硬件压入SP
2. 硬件从中断向量装入新的PC
3. 汇编语言过程保存寄存器的值
4. 汇编语言过程设置新的堆栈
5. C中断服务器运行（典型IO）
6. 调度器决定下面那个程序先运行
7. C过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程



管程是程序、变量和数据结构等组成的一个集合



关于调度系统

公平：给每个进程公平的CPU份额

策略强制执行：保证规定的策略被执行

平衡：保证系统的所有部分都忙碌



批处理系统

吞吐量：每小时最大作业数

周转时间：从提交到终止间的最小时间

CPU利用率：保持CPU始终忙碌



交互式系统

响应时间：快速响应请求

均衡性：满足用户的期望



实时系统

满足截止时间：避免数据丢失

可预测性：多媒体系统中避免品质降低



批处理中的调度

先来先服务：利用链表式结构从头至尾按顺序分配

最短作业优先：优先执行花费时间短的作业

最短剩余时间优先：优先执行剩余时间最少的作业



交互式系统中的调度：

轮询制度：每个进程被分配一个时间段，在这个时间片内允许进程运行。如果超过时间CPU立刻分配给另一个进程。如果进程提前阻塞或结束，则CPU立刻切换

优先级调度：优先级高的进程优先运行，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果优先级次序发生变化，则会进行进程切换。



把物理内存暴露给进程的两个缺点：

- 如果用户程序可以寻址内存的每个字节，它们就很容易破坏操作系统
- 很难运行多个程序，如果只有一个CPU就只能顺序执行



地址空间是进程可以用户来寻址内存的地址集



基址寄存器：存储数据内存的起始位置

变址寄存器：存储应用程序的长度



每当进程引用内存以获取指令或读取、写入数据时，CPU都会自动将基址值添加到进程生成的地址中，然后将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于变址寄存器的范围，如果超过，那么会产生错误并终止访问。



运行时重定位 

PCB里存储进程的基址

每执行一条指令都要从逻辑地址里计算出物理地址：地址翻译

进程切换时根据PCB切换一起更换基址



不是将整个程序直接放入内存，而是分段

<段号，段内偏移>  mov<3,2K>

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

data segment（segment 段定义指的是一段连续的内存空间）

- 代码段   code segment 文本段，用来存放指令、运行代码的一块内存空间
- 数据段 data segment 存储初始化的全局变量和static变量
- bss段 bss segment 存储未初始化的全局变量和static变量
- rodata段 常量区
- 栈  stack 存储的是函数或代码中的局部变量
- 堆  heap 存储的是程序运行期间动态分配的malloc/realloc空间



内存针对自动增长的区域的三种方式

1. 如果一个进程与空闲区相邻，那么可把空闲区直接分配给进程以增大
2. 如果进程相邻的是另外一个进程，要么把需要增长的进程移动到空间足够大的位置；要么把一或多个进程交换出去，生成一个足够大的空闲区
3. 直接挂起一部分空闲空间或者结束该进程



监控内存使用的两种方法

- 位图

- 空闲列表

  使用链表进行管理

  - 首次适配
  - 下次适配
  - 最佳适配
  - 最差适配
  - 快速适配



虚拟内存 

​	当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令







